---
title: 关键字
date: 2018-09-04 11:38:57
tags:
  - 泛型
  - 高级函数
categories:
  - 开发
index_img: /images/CoverImage/wallhaven-2eo156.jpg
---

# < T >

1. 函数名后

```示例
    func swapTwoValues<T>(inout a:T, inout _ b:T) {
        let tempValue = a
        a = b
        b = tempValue
    }

    var someInt = 3,someIntTwo = 5
    var oneGenericValue = "one"
    var twoGenericValue = "two"
    swapTwoValues(&oneGenericValue, &twoGenericValue)
    swapTwoValues(&someInt, &someIntTwo)
    print(oneGenericValue) // two
    print(someIntTwo)      // 3
```

<!-- more -->

- 上面的代码可以看*泛型* Generics 语法
- 占位类型名 T 放在 <> 中，尖括号告诉 Swift ，T 在上述函数中是一个占位类型名
- T 没有明确表示是什么类型，但是上述函数中可以看出 a 和 b 必须是 T 类型

> 引申：泛型
> 泛型 能让我们写出灵活可重复使用的方法和类型
> Array 和 Dictionary 都是泛型容器

- 举例

```Head
    struct GenericStack<T> {
        var items = [T]()
        mutating func push(item: T) {
            items.append(item)
        }
        mutating func pop() ->T {
            return items.removeLast()
        }
    }
    var stackOfStrings = GenericStack<String>()
    stackOfStrings.push("uno")
    stackOfStrings.push("dos")
    stackOfStrings.push("tres")
    stackOfStrings.push("cuatro")
    let popItem = stackOfStrings.pop() // popItem 等于 "cuatro"
```

# mutating

1. Swift 中的 protocol 不仅可以被 class 类型实现，也适用于 struct 和 enum
2. mutating 修饰方法为了能在该方法中修改 struct 或者是 enum 的变量

```示例
protocol Vehicle
{
    var numberOfWheels: Int {get}
    var color: UIColor {get set}

    mutating func changeColor()
}

struct MyCar: Vehicle {
    let numberOfWheels = 4
    var color = UIColor.blueColor()

    mutating func changeColor() {
        color = UIColor.redColor()
    }
}
```

- 如果如果把 protocol 定义中的 mutating 去掉的话，MyCar 就怎么都过不了编译了，会报错说没有实现接口
- 如果去掉 struct 中的 mutating 的话，会报错说不能改变结构体成员
- 另一个例子

```示例
struct IntStack {
    var items = [Int]()
    mutating func push(item: Int) {
        items.append(item)
    }
    mutating func pop() ->Int {
        return items.removeLast()
    }
}
let pushItem = 5
var intStack = IntStack()
intStack.push(pushItem)
```
